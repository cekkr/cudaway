"""CUDA Runtime â†” HIP mapping generator.

This helper ingests the CUDA Runtime API reference and the AMD HIP programming guide, extracts
API symbols, correlates them via naming heuristics, and emits both JSON metadata and
C++-consumable stub tables.
"""
from __future__ import annotations

import argparse
from dataclasses import asdict, dataclass
from datetime import datetime, timezone
import json
from pathlib import Path
from typing import Dict, Iterable, List

from .common.pdf_utils import SymbolData, extract_prefixed_symbols


@dataclass
class MappingEntry:
    cuda_symbol: str
    hip_symbol: str
    hip_documented: bool
    cuda_pages: List[int]
    hip_pages: List[int]
    status: str
    notes: str

    def to_dict(self) -> Dict[str, object]:
        payload = asdict(self)
        payload["cuda_pages"] = list(self.cuda_pages)
        payload["hip_pages"] = list(self.hip_pages)
        return payload


def build_mapping(  # noqa: PLR0913 complex enough? ignore
    cuda_symbols: Dict[str, SymbolData],
    hip_symbols: Dict[str, SymbolData],
    default_status: str,
) -> List[MappingEntry]:
    entries: List[MappingEntry] = []
    for cuda_symbol in sorted(cuda_symbols.keys()):
        if not cuda_symbol.startswith("cuda"):
            continue
        base = cuda_symbol[len("cuda") :]
        if not base:
            continue
        hip_symbol = f"hip{base}"
        hip_data = hip_symbols.get(hip_symbol)
        notes = (
            "HIP guide documents this symbol."
            if hip_data is not None
            else "No HIP documentation match; manual shim required."
        )
        entry = MappingEntry(
            cuda_symbol=cuda_symbol,
            hip_symbol=hip_symbol,
            hip_documented=hip_data is not None,
            cuda_pages=list(cuda_symbols[cuda_symbol].pages),
            hip_pages=list(hip_data.pages if hip_data else []),
            status=default_status,
            notes=notes,
        )
        entries.append(entry)
    return entries


def generate_json_payload(
    entries: Iterable[MappingEntry],
    cuda_pdf: Path,
    hip_pdf: Path,
    hip_only_symbols: List[str],
) -> Dict[str, object]:
    entries_list = list(entries)
    covered = sum(1 for entry in entries_list if entry.hip_documented)
    metadata = {
        "generated_at": datetime.now(timezone.utc).isoformat(),
        "cuda_pdf": str(cuda_pdf),
        "hip_pdf": str(hip_pdf),
        "entry_count": len(entries_list),
        "hip_documented": covered,
        "hip_missing": len(entries_list) - covered,
    }
    return {
        "metadata": metadata,
        "entries": [entry.to_dict() for entry in entries_list],
        "hip_only_symbols": hip_only_symbols,
    }


def write_json(path: Path, payload: Dict[str, object]) -> None:
    path.parent.mkdir(parents=True, exist_ok=True)
    with path.open("w", encoding="utf-8") as fh:
        json.dump(payload, fh, indent=2)
        fh.write("\n")


def escape_cpp(value: str) -> str:
    return (
        value.replace("\\", "\\\\")
        .replace("\"", r"\"")
        .replace("\n", "\\n")
    )


def render_stub_table(entries: Iterable[MappingEntry], metadata: Dict[str, object]) -> str:
    entries_list = list(entries)
    lines = [
        "// Generated by tools/python/cuda_runtime_converter.py",
        f"// Source CUDA doc : {metadata['cuda_pdf']}",
        f"// Source HIP doc  : {metadata['hip_pdf']}",
        f"// Generated at     : {metadata['generated_at']}",
        "#pragma once",
        "",
        "#include <array>",
        "#include <string_view>",
        "",
        "namespace cudaway::host::runtime {",
        "",
        "struct RuntimeApiEntry {",
        "    std::string_view cudaSymbol;",
        "    std::string_view hipSymbol;",
        "    bool hipDocumented;",
        "    std::string_view status;",
        "    std::string_view notes;",
        "};",
        "",
        f"inline constexpr std::array<RuntimeApiEntry, {len(entries_list)}> kRuntimeApiTable{{",
    ]
    for entry in entries_list:
        notes_parts = []
        if entry.cuda_pages:
            notes_parts.append(
                "CUDA pgs " + ", ".join(str(num) for num in entry.cuda_pages)
            )
        if entry.hip_pages:
            notes_parts.append(
                "HIP pgs " + ", ".join(str(num) for num in entry.hip_pages)
            )
        notes_parts.append(entry.notes)
        notes = " | ".join(notes_parts)
        lines.append(
            "    RuntimeApiEntry{" +
            f'"{entry.cuda_symbol}", "{entry.hip_symbol}", ' +
            ("true" if entry.hip_documented else "false") + ", " +
            f'"{escape_cpp(entry.status)}", "{escape_cpp(notes)}"' +
            "},"
        )
    lines.extend(
        [
            "};",
            "",
            "}  // namespace cudaway::host::runtime",
        ]
    )
    return "\n".join(lines) + "\n"


def write_stub_header(path: Path, header: str) -> None:
    path.parent.mkdir(parents=True, exist_ok=True)
    with path.open("w", encoding="utf-8") as fh:
        fh.write(header)


def main(argv: list[str] | None = None) -> None:
    parser = argparse.ArgumentParser(description=__doc__)
    parser.add_argument(
        "--cuda-pdf",
        default="studies/APIs/CUDA_Runtime_API.pdf",
        type=Path,
        help="Path to the CUDA Runtime API reference PDF.",
    )
    parser.add_argument(
        "--hip-pdf",
        default="studies/APIs/AMD_HIP_Programming_Guide.pdf",
        type=Path,
        help="Path to the AMD HIP programming guide PDF.",
    )
    parser.add_argument(
        "--json-out",
        default="tools/data/cuda_runtime_mappings.json",
        type=Path,
        help="Output JSON path for the mapping data.",
    )
    parser.add_argument(
        "--stub-out",
        default="src/host/runtime/RuntimeStubTable.generated.hpp",
        type=Path,
        help="Path to the generated C++ stub header.",
    )
    parser.add_argument(
        "--default-status",
        default="pending",
        help="Status string assigned to each mapping entry (default: pending).",
    )
    args = parser.parse_args(argv)

    if not args.cuda_pdf.exists():
        raise SystemExit(f"CUDA PDF not found: {args.cuda_pdf}")
    if not args.hip_pdf.exists():
        raise SystemExit(f"HIP PDF not found: {args.hip_pdf}")

    cuda_symbols = extract_prefixed_symbols(args.cuda_pdf, "cuda")
    hip_symbols = extract_prefixed_symbols(args.hip_pdf, "hip")
    entries = build_mapping(cuda_symbols, hip_symbols, default_status=args.default_status)

    hip_only = sorted(set(hip_symbols.keys()) - {entry.hip_symbol for entry in entries})
    payload = generate_json_payload(entries, args.cuda_pdf, args.hip_pdf, hip_only)
    write_json(args.json_out, payload)
    header = render_stub_table(entries, payload["metadata"])
    write_stub_header(args.stub_out, header)
    print(
        f"Generated {len(entries)} mapping entries "
        f"({payload['metadata']['hip_documented']} HIP-documented)."
    )
    print(f"JSON  -> {args.json_out}")
    print(f"Stubs -> {args.stub_out}")


if __name__ == "__main__":
    main()
